initSidebarItems({"macro":[["addrs_of!","Make a tuple of the addresses of some of a struct's fields.This is useful when you are transmuting between struct types and would like an additional dynamic check that the layouts match. It's difficult to make such an assertion statically in Rust at present.Example"],["do_while!","Do-while loop.ExamplesThe loop always executes at least once."],["ext_bail!","Call `span_err` on an `ExtCtxt` and return `DummyResult::any`."],["ext_bail_if!","`ext_bail!` if the condition `$e` is true."],["ext_expect!","Unwrap the `Option` `$e`, or `ext_bail!`."],["format_if!","Conditionally perform string formatting.If `$enabled` is true, then do the formatting and return a `Cow::Owned`.Otherwise, just return the borrowed (often `'static`) string `$borrowed`.When `$enabled` is false, this avoids the overhead of allocating and writing to a buffer, as well as any overhead or side effects of the format arguments.ExampleYou can use `format_if` to implement a detailed error logging facility that can be enabled at runtime."],["matches!","Returns true if an expression matches a pattern.Example"],["test_eq!","Generate a test function `$name` which asserts that `$left` and `$right` are equal.Example"],["unwrap_or_return!","Unwraps an `Option` or returns from the function with the specified return value.Can be used on `Result`s by first calling `.ok()` or `.err()` on them.Examples"]],"mod":[["format","Macros for string formatting."],["matches","Pattern Matching macros."],["mem","Macros for low-level memory manipulation."],["syntax_ext","Macros useful when writing procedural syntax extensions.The macros themselves are ordinary `macro_rules!` macros."],["test","Macros for writing test suites."]]});